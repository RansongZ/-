## 最近，服务准备上线，统一对微服务增加JVM参数，发现垃圾回收偏长，而我们的服务是一个响应时间优先的应用，需要对GC进行部分参数调优。

{% fancybox %}

![img](https://ransongblog.oss-cn-hangzhou.aliyuncs.com/solong3dao.jpg)

{% endfancybox %}

## 一、首先 添加jvm参数查看gc日志： -Xloggc:/usr/project/web-task/gc.log

**(8核）如下是8核机器的GC，CMS，young gc基本在100ms左右**

<!--more-->

[GC (Allocation Failure) 1540815K->708720K(1992320K), 0.1204106 secs]
[GC (Allocation Failure) 1547632K->718037K(1992320K), 0.1039874 secs]
[GC (Allocation Failure) 1568245K->734990K(1992320K), 0.0979778 secs]
[GC (Allocation Failure) 1573902K->739338K(1992320K), 0.1270793 secs]
[GC (Allocation Failure) 1578250K->743388K(1992320K), 0.1074495 secs]

(8核）经发现与GC线程有关，通过指定并发GC线程数 -XX:ParallelGCThreads=8 -XX:ConcGCThreads=4，得到

{% fancybox %}

![img](https://pic2.zhimg.com/80/v2-9507683f4822287157f301259e219421_720w.jpg)

{% endfancybox %}

设置的大小主要取决于 ：cpu核数

年轻代的并行线程数（ParallelGCThreads）：

```java
return (ncpus <= 8) ? ncpus : MAX2(8, ncpus / 2)  
```

CMS并行线程数（ConcGCThreads）：

```java
if (AdjustGCThreadsToCores) {  
  FLAG_SET_DEFAULT(ConcGCThreads, ParallelGCThreads / 2);  
} else {  
  FLAG_SET_DEFAULT(ConcGCThreads, (3 + ParallelGCThreads) / 4);  
}  
```

详情参考：[Better default for ParallelGCThreads and ConcGCThreads by using number of physical cores and CPU mask.](https://link.zhihu.com/?target=http%3A//mail.openjdk.java.net/pipermail/hotspot-gc-dev/2013-November/008952.html)

## 二. 详解线上某服务的CMS收集器JVM参数

**export JAVA_OPTS="-Djava.library.path=/usr/local/lib -server**

**-XX:+UseConcMarkSweepGC**

**-Xss256k**

**-Xms4g**

**-Xmx4g**

**-server**

**-XX:NewRatio=1**

**-XX:SurvivorRatio=8**

**-XX:ReservedCodeCacheSize=64m**

**-XX:TLABWasteTargetPercent=10**

**-XX:+CMSParallelRemarkEnabled**

**-XX:+ParallelRefProcEnabled**

**-XX:+CMSClassUnloadingEnabled**

**-XX:CMSInitiatingOccupancyFraction=70**

**-XX:+UseCMSInitiatingOccupancyOnly**

**-XX:ParallelGCThreads=8**

**-XX:ConcGCThreads=4**

**-XX:MaxDirectMemorySize=256m**

**-XX:MaxTenuringThreshold=3**

**-XX:ParGCCardsPerStrideChunk=32768 （不推荐分配内存比较小使用）**

**-XX:+AlwaysPreTouch**





**//详细含义**

**-XX:ReservedCodeCacheSize=64m** 用来存储已编译方法生成的本地代码缓存

**-XX:TLABWasteTargetPercent=10** TLAB空间所占用Eden空间的百分比大小。虚拟机会为每个Java线程分配一块TLAB空间

**-XX:+UseConcMarkSweepGC**

**-XX:+CMSParallelRemarkEnabled** 降低标记停顿

**-XX:+ParallelRefProcEnabled** 默认为false，并行的处理Reference对象，如WeakReference，除非在GC log里出现Reference处理时间较长的日志，否则效果不会很明显。

**-XX:+CMSClassUnloadingEnabled** 在CMS中清理永久代中的过期的Class而不等到Full GC，JDK7默认关闭而JDK8打开。看自己情况，比如有没有运行动态语言脚本如Groovy产生大量的临时类。它会增加CMS remark的暂停时间，所以如果新类加载并不频繁，这个参数还是不开的好。

**-XX:CMSInitiatingOccupancyFraction=70** 与 -XX:+UseCMSInitiatingOccupancyOnly：两个参数需要配合使用，否则第一个参数的75只是一个参考值，JVM会重新计算GC的时间。

**-XX:+UseCMSInitiatingOccupancyOnly**

**-XX:ParallelGCThreads=8** GC的线程数

**-XX:ConcGCThreads=4** 并发线程数

**-Xss256k**

**-Xms4g**

**-Xmx4g**

**-XX:MaxDirectMemorySize=256m**

-XX:MaxDirectMemorySize=size用于设置New I/O(java.nio) direct-buffer allocations的最大大小，size的单位可以使用k/K、m/M、g/G；如果没有设置该参数则默认值为0，意味着JVM自己自动给NIO direct-buffer allocations选择最大大小；从代码java.base/jdk/internal/misc/VM.java中可以看到默认是取的Runtime.getRuntime().maxMemory()

**-XX:MaxTenuringThreshold=3** 设置的是年龄阈值，默认15（对象被复制的次数）

**-XX:NewRatio=1**

**-XX:SurvivorRatio=8**

**-XX:+UnlockDiagnosticVMOptions （不推荐）**

**[https://blog.csdn.net/u013504720/article/details/78724836](https://link.zhihu.com/?target=https%3A//blog.csdn.net/u013504720/article/details/78724836)**

**-XX:ParGCCardsPerStrideChunk=32768**

**[https://www.jianshu.com/p/3b1e33e0ccaf](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/3b1e33e0ccaf)**

**-XX:+AlwaysPreTouch**

在启动时把所有参数定义的内存全部捋一遍。使用这个参数可能会使启动变慢，但是在后面内存使用过程中会更快。可以保证内存页面连续分配，新生代晋升时不会因为申请内存页面使GC停顿加长。通常只有在内存大于32G的时候才会有感觉。

**-XX:+HeapDumpOnOutOfMemoryError (线上生产一般用此参数，不用打gc.log日志）**

在应用启动时配置参数 ，当应用抛出OutOfMemoryError时自动生成dump文件。

-Des.networkaddress.cache.ttl=60  

-Des.networkaddress.cache.negative.ttl=10

前面两个搭配使用：浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。ava的网络应用程序的DNS缓存是由JVM的缓存策略控制的，当InetAddress类第一次使用某个域名（如www.google.com）创建InetAddress对象后，JVM就会将这个域名和它从DNS上获得的信息（如IP地址）都保存在DNS缓存中。当下一次InetAddress类再使用这个域名时，就直接从DNS缓存里获得所需的信息，而无需再访问DNS服务器

-XX:-OmitStackTraceInFastThrow 关闭一个JDK优化，该优化将丢弃堆栈跟踪异常，因为堆栈跟踪对调试很重要，就是说强制让jvm抛出堆栈异常

**-XX:CMSFullGCsBeforeCompaction**, 这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的

**-Xloggc:/usr/project/web-task/gc.log** ## 指定GC日志文件的输出路径

**-XX:HeapDumpPath=/usr/project/web-task/gc.hprof** ## 表示生成DUMP文件的路径，也可以指定文件名称，如果不指定文件名，默认为：java_<pid>_<date>_<time>_heapDump.hprof。

- **将Xms和Xmx设为一样的值**。如果虚拟机启动时设置使用的内存比较小，这个时候又需要初始化很多对象，虚拟机就必须重复地增加内存。

## 三、简单讲解为什么选用CMS -下面摘自：深入理解java虚拟机(第三版)3.6

**3.1 先看看CMS的优缺点**

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。

CMS收集器是基于标记-清除算法 : 初始标记->并发标记->重新标记->并发清除

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。**初始标记**仅仅只是标记一下GC Roots能**直接关联到的对象**，速度很快；**并发标记**阶段就是从GC Roots的**直接关联对**象**开始遍历整个对象图的过程**，这个过程**耗时较长但是不需要停顿用户线程**，可以与垃圾收集线程一起**并发运行**；而**重新标记**阶段则是为了**修正**并发标记期间，因用户**程序继续运作而导致标记产生变动**的那一部分**对象的标记记录**（详见3.4.6节中关于增量更新的讲解），这个阶段的停顿时间通常会比初始标记**阶段稍长一些**，但也远比**并发标记**阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程**同时并发**的。

CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，**并且会随着处理器核心数量的增加而下降**。但是当处理器核心数量**不足四个**时，CMS对用户程序的**影响**就可能变得**很大**

在**CMS的并发标记和并发清理阶段**，用户线程是还在继续运行的，程序在运行自然就还会伴随有**新的垃圾**对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“**浮动垃圾**”。同样也是由于在垃圾收集阶段**用户线程还需要持续运行**，那就还需要**预留足够内存**空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK 5的默认设置下，CMS收集器当老年代使用了**68%**的空间后就会被激活，这是一个偏保守的设置，如果在实际应用中老年代增长并不是太快，可以适当**调高**参数**-XX：CMSInitiatingOccu-pancyFraction**的值来提高**CMS的触发百分比**，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动阈值就已经默认提升至**92%**。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。所以参数**-XX：CMSInitiatingOccupancyFraction**设置得**太高**将会很容易**导致大量的并发失败产生**，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。

还有最后一个缺点，在本节的开头曾提到，CMS是一款基于“标记-清除”算法实现的收集器，如果读者对前面这部分介绍还有印象的话，就可能想到这意味着收集结束时会有**大量空间碎片产生**。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现**老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象**，而不得不提前**触发一次Full GC**的情况。为了解决这个问题，CMS收集器提供了一个**-XX：+UseCMS-CompactAtFullCollection**开关参数（默认是开启的，此参数从JDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的**合并整理**过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片**问题是解决**了，但**停顿时间又会变长**，因此虚拟机设计者们还提供了另外一个参数**-XX：CMSFullGCsBefore-Compaction**（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。

**3.2 看看G1**

G1是一款主要**面向服务端应用**的垃圾收集器。HotSpot开发团队最初赋予它的期望是（在比较长期的）未来可以替换掉JDK 5中发布的CMS收集器。现在这个期望目标已经实现过半了，JDK9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器[插图]。如果对JDK 9及以上版本的HotSpot虚拟机使用参数-XX：+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃：

但作为一款曾被广泛运用过的收集器，经过多个版本的开发迭代后，CMS（以及之前几款收集器）的代码与HotSpot的**内存管理、执行、编译、监控**等子系统都有千丝万缕的联系，这是历史原因导致的，并不符合职责分离的设计原则。为此，规划JDK 10功能目标时，HotSpot虚拟机提出了“统一垃圾收集器接口”[插图]，将**内存回收的“行为”与“实现”进行分离**，CMS以及其他收集器都重构成基于这套接口的一种实现。以此为基础，日后要移除或者加入某一款收集器，都会变得容易许多，风险也可以控制，这算是在为CMS退出历史舞台铺下最后的道路了。

那具体要怎么做才能实现这个目标呢？首先要有一个思想上的改变，在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以**面向堆内存任何部分来组成回收集**（Collection Set，一般简称CSet）进行回收，**衡量标准不再是它属于哪个分代**，而是哪块**内存中存放的垃圾数量最多，回收收益最大**，这就是G1收集器的Mixed GC模式。

G1开创的基于**Region的堆内存布局**是它能够实现这个目标的关键。虽然G1也仍是**遵循分代收集**理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：**G1不再坚持固定大小以及固定数量的分代区域划分**，而是把连续的**Java堆划分为多个大小相等的独立区域**（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

Region中还有一类特殊的**Humongous**区域，专门用来**存储大对象**。G1认为只要大小超过了一个**Region容量一半**的对象即可**判定为大对象**。每个Region的大小可以通过参数-**XX：G1HeapRegionSize**设定，取值范围为1MB～32MB，且应为**2的N次幂**。而对于那些超过了整个Region容量的超级大对象，将会被存放在**N个连续的Humongous Region**之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待，如图3-12所示。

{% fancybox %}

![img](https://pic4.zhimg.com/80/v2-2fb52db5c3c0bd52ffc3370fcc76d43f_720w.jpg)

{% endfancybox %}

虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立**可预测的停顿时间模型**，是因为它将**Region**作为**单次回收的最小单元**，即**每次收集到的内存空间都是Region大小的整数倍**，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的**垃圾堆积的“价值”大小**，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个**优先级列表**，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），**优先处理回收价值收益最大的那些Region**，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。

G1将堆内存“化整为零”的“解题思路”，看起来似乎没有太多令人惊讶之处，也完全不难理解，但其中的实现细节可是远远没有想象中那么简单，否则就不会从2004年Sun实验室发表第一篇关于G1的论文后一直拖到2012年4月JDK 7 Update 4发布，用将近10年时间才倒腾出能够商用的G1收集器来。G1收集器至少有（不限于）以下这些关键的细节问题需要妥善解决：

·譬如，将Java堆分成多个独立Region后，Region里面存在的**跨Region引用对象如何解决**？解决的思路我们已经知道（见3.3.1节和3.4.4节）：使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。

·譬如，在**并发标记阶段**如何保证**收集线程与用户线程互不干扰**地运行？这里首先要解决的是用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误，该问题的解决办法笔者已经抽出独立小节来讲解过（见3.4.6节）：CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的。此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。

譬如，**怎样建立起可靠的停顿预测模型**？用户通过-XX：MaxGCPauseMillis参数指定的停顿时间只意味着垃圾收集发生之前的期望值，但G1收集器要怎么做才能满足用户的期望呢？G1收集器的停顿预测模型是以衰减均值（Decaying Average）为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“最近的”平均状态。换句话说，Region的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。

如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下四个步骤：

. **初始标记**（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

·**并发标记**（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。

·**最终标记**（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。

·**筛选回收**（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全**暂停用户线程**的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在**延迟可控的情况下获得尽可能高的吞吐量**，所以才能担当起“全功能收集器”的重任与期望。

毫无疑问，可以由用户指定期望的停顿时间是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。不过，这里设置的“期望值”必须是符合实际的，不能异想天开，毕竟G1是要冻结用户线程来复制对象的，这个停顿时间再怎么低也得有个限度。它默认的**停顿目标为两百毫秒**，一般来说，回收阶段占到几十到一百甚至接近两百毫秒都很正常，但如果我们把停顿时间调得非常低，譬如设置为二十毫秒，很可能出现的结果就是由于**停顿目标时间太短**，导致每次选出来的回收集只占堆**内存很小的一部分**，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积。很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间，但应用运行时间一长就不行了，最终占满堆**引发Full GC反而降低性能**，所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。

**3.3 比较一下**

G1收集器常会被拿来与CMS收集器互相比较，毕竟它们都非常关注停顿时间的控制，官方资料[插图]中将它们两个并称为“The Mostly Concurrent Collectors”。在未来，G1收集器最终还是要取代CMS的，而当下它们两者并存的时间里，分个高低优劣就无可避免。

相比CMS，G1的优点有很多，暂且不论可以**指定最大停顿时间**、**分Region的内存布局**、**按收益动态确定回收集**这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力。与CMS的“标记-清除”算法不同，**G1从整体来看是基于“标记-整理”算法**实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着**G1运作期间不会产生内存空间碎片**，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。

不过，G1相对于CMS仍然不是占全方位、压倒性优势的，从它出现几年仍不能在所有应用场景中代替CMS就可以得知这个结论。比起CMS，G1的弱项也可以列举出不少，如在用户程序运行过程中，G1无论是为了垃圾收集产生的**内存占用**（Footprint）还是程序运行时的**额外执行负载**（Overload）都要比CMS要高。就内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占**整个堆容量的20%乃至更多的内存空间**；相比起来CMS的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的。

在**执行负载**的角度上，同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会有不同，譬如它们都使用到**写屏障**，**CMS用写后屏障来更新维护卡表**；而G1除了使用写后屏障来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）**卡表维护操作外**，为了实现**原始快照搜索（SATB）算法**，还需要使用写前屏障来**跟踪**并发时的指针**变化情况**。相比起增量更新算法，原始**快照搜索**能够**减少**并发标记和重新标记阶段的**消耗**，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源，所以CMS的写屏障实现是直接的同步操作，而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。

总结：以上的优缺点对比仅仅是针对G1和CMS两款垃圾收集器单独某方面的实现细节的定性分析，通常我们说哪款收集器要更好、要好上多少，往往是针对具体场景才能做的定量比较。按照笔者的实践经验，**目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间**，当然，以上这些也仅是经验之谈，不同应用需要量体裁衣地实际测试才能得出最合适的结论，随着HotSpot的开发者对G1的不断优化，也会让对比结果继续向G1倾斜。

**3.4** **衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”**

**Shenandoah**和**ZGC**，几乎整个工作过程全部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上是固定的，与堆的容量、堆中对象的数量没有正比例关系。实际上，它们都可以在任意可管理的（譬如现在ZGC只能管理4TB以内的堆）堆容量下，实现垃圾收集的停顿都不超过十毫秒这种以前听起来是天方夜谭、匪夷所思的目标。这两款目前仍处于实验状态的收集器，被官方命名为“低延迟垃圾收集器”（Low-Latency Garbage Collector或者Low-Pause-Time GarbageCollector）。

**说说ZGC**

ZGC在实现细节上做了一些不同的权衡选择，譬如G1需要通过写屏障来维护记忆集，才能处理跨代指针，得以实现Region的增量回收。记忆集要占用大量的内存空间，写屏障也对正常程序运行造成额外负担，这些都是权衡选择的代价。**ZGC就完全没有使用记忆集**，它甚至连**分代都没有**，连像CMS中那样只记录新生代和老年代间引用的**卡表也不需要**，因而完全**没有用到写屏障**，所以给用户线程带来的**运行负担也要小**得多。可是，必定要有优有劣才会称作权衡，ZGC的这种选择[插图]也限制了它能承受的对**象分配速率不会太高**，可以想象以下场景来理解ZGC的这个劣势：ZGC准备要对一个很大的堆做一次完整的并发收集，假设其全过程要持续十分钟以上（请读者切勿混淆并发时间与停顿时间，ZGC立的Flag是停顿时间不超过十毫秒），在这段时间里面，由于**应用的对象分配速率很高，将创造大量的新对象**，这些新对象很难进入当次收集的标记范围，通常就只能全部当作存活对象来看待——尽管其中绝大部分对象都是朝生夕灭的，这就产生了大量的浮动垃圾。如果这种高速分配持续维持的话，每一次完整的并发收集周期都会很长，回收到的内存空间持续小于期间并发产生的浮动垃圾所占的空间，堆中剩余可腾挪的空间就越来越小了。目前唯一的办法就是**尽可能地增加堆容量大小**，获得更多喘息的时间。但是若要从根本上提升ZGC能够应对的对象分配速率，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。Azul的C4收集器实现了分代收集后，能够应对的对象分配速率就比不分代的PGC收集器提升了十倍之多。





欢迎关注我的微信公众号，会首发一些最新文章哦！

{% fancybox %}

![solong](https://ransongblog.oss-cn-hangzhou.aliyuncs.com/wechat_public_for_tingyu.jpg)

{% endfancybox %}